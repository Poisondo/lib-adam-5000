/*********************************************************************************************
Project :
Version :
Date    : 30.03.2011
Author  : Шиенков Д.И.
Company :
Comments:
License : New BSD
**********************************************************************************************/

/*! \file mio.cpp

    Аббревиатура модуля (файла) "mio" - Module Input Output.

    Здесь реализован API для доступа к модулям локального I/O ПЛК серии ADAM 5510. \n

    Модули I/O ПЛК делятся на высокоскоростные и низкоскоростные.
    Получение данных из высокоскоростных модулей производится напрямую путем чтения портов этих модулей
    по базовым адресам и соответствующих их смещениям.
    Получение данных из низкоскоростных модулей производится путем обмена командами с модулем по
    через внутреннюю UART шину модуля по протоколу типа DCON.

*/

#include <dos.h>
#include <conio.h>
#include "mio.h"


//--------------------------------------------------------------------------------------------------------//
/*** ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ ***/

/*! Базовые адреса слотов 0 - 7 ПЛК. \n
    Исходя из анализа декомпилированного ассемблерного кода (с помощью IDA)
    библиотек от Advantech видно, что каждый из 8 слотов для посадки модуля имеет
    свой базовый адрес (например, слот №0 - адрес 0х0100).
    Базовые адреса модулей чередуются через 16 регистров, т.е. каждый модуль
    имеет теоретически по 16 регистров (адресов, смещений) ввода/вывода. \n
    Для каждого конкретного типа модуля назначение этих регистров может быть разное
    и это назначение можно узнать проанализировав декомпилированный ассемблерный код библиотек
    от Advantech!
*/
static const int board_base[8] = { 0x0100, 0x0110, 0x0120, 0x0130, 0x0140, 0x0150, 0x0160, 0x0170 };

/*! Битовые маски каждого бита в байте,
    используются просто для оптимизации алгоитмов и кода.
*/
static const char bit_mask[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };

static char can_xxx_proc[8] = { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01 };

/*! Массив из 8-ми элементов, которые являются предыдущими
    значениями каналов дискретных модулей ввода или вывода в слотах 0 - 7:
    - при получении текущих значений каналов с модулей DI, эти текущие значения сразу
    сохраняются в массив (хз для чего это сделано, нужно подумать)
    - при выдаче управления каналами в модули DO, желаемые значения каналов сохраняются
    в массив (это типа нужно чтобы косвенно определить текущее состояние каналов модуля
    DO, т.к. нет? возможности определить программно это состояние прочитав регистры модуля!).
    .
*/
static int dio_val[8] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000 };

//--------------------------------------------------------------------------------------------------------//
/*** ЛОКАЛЬНЫЕ ФУНКЦИИ ***/

//--------------------------------------------------------------------------------------------------------//
/*** ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ***/

//--------------------------------------------------------------------------------------------------------//
/*** ГЛОБАЛЬНЫЕ ФУНКЦИИ ***/

/*!
*/
void get_di_val(int slot, int *val)
{
    *val = (inp(board_base[slot] + 3) << 8) | inp(board_base[slot] + 2);//получили текущее значение +2/+3
    if (can_xxx_proc[slot]) {//если функцию вызвали впервые то читаем регистры +4/+5
        can_xxx_proc[slot] = 0;//делаем так чтобы при след. вызове не читать ХЗ регистры

        // Занимаемся преобразованием значений из ХЗ регистров +4/+5
        {
            dio_val[slot] = ((~(inp(board_base[slot] + 5))) << 8) | (~(inp(board_base[slot] + 4)));
            int old_val = 0;
            for (int i = 0; i < 8; ++i) {
                //lo
                if ((bit_mask[i] & 0x00FF) & dio_val[slot]) { old_val += bit_mask[7 - i]; }
                //hi
                if ((bit_mask[i] << 8) & dio_val[slot]) { old_val += bit_mask[7 - i] << 8; }
            }
            dio_val[slot] = old_val;
        }
    }
    *val ^= dio_val[slot];
}

/*! 
*/
// По 1 биту устанавливаем или сбрасываем!!!
void set_do_bit(int slot, int bit, int val)
{
    if ((8 > slot) && (16 > bit)) {
        if (val) { dio_val[slot] |= (1 << bit); }
        else { dio_val[slot] &= ~(1 << bit); }
        outp(board_base[slot] + 2, dio_val[slot]); //lo
        outp(board_base[slot] + 3, dio_val[slot] >> 8);//hi
    }
}


